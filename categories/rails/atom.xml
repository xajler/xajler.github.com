<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Learn-a-holic Geek Notes]]></title>
  <link href="http://learnaholic.me/categories/rails/atom.xml" rel="self"/>
  <link href="http://learnaholic.me/"/>
  <updated>2014-01-09T14:35:39+01:00</updated>
  <id>http://learnaholic.me/</id>
  <author>
    <name><![CDATA[Kornelije Sajler]]></name>
    <email><![CDATA[xajler@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails App from Scratch: User Save and Update]]></title>
    <link href="http://learnaholic.me/2012/11/08/rails-app-from-scratch-user-save-and-update/"/>
    <updated>2012-11-08T01:25:00+01:00</updated>
    <id>http://learnaholic.me/2012/11/08/rails-app-from-scratch-user-save-and-update</id>
    <content type="html"><![CDATA[<p>After we implemented logic around User attributes, it is time to finally save and update
the User to the database.</p>

<p>But first, we shall change a mistake from the post on creating Sign Up page, the <code>password</code>
fields in the View are set as normal text. We shall make sure that it is a password field!</p>

<p>Change the <code>text_field</code> to <code>password_field</code> in <code>app/views/users/_form.html.haml</code>:</p>

<p>```haml
= f.label :password, 'Password:'
= f.password_field :password
%br</p>

<p>= f.label :password_confirmation, 'Confirm Password:'
= f.password_field :password_confirmation
%br
```</p>

<h2>Saving Valid User Test</h2>

<p>Now when the password fields are fixed, lets create a test to save a Valid User to the
database.</p>

<p>Create a new <code>context</code> for <code>POST</code> in <code>spec/requests/users_spec.rb</code>:</p>

<p>```ruby
context 'POST /users' do
  it 'creates and saves the valid user' do</p>

<pre><code>visit new_user_path

fill_in 'Email', with: 'xajler@gmail.com'
fill_in 'Password', with: 'x1234567'
fill_in 'Confirm Password', with: 'x1234567'
fill_in 'Full Name', with: 'Kornelije Sajler'
click_button 'Sign Up'

current_path.should == signup_path
page.should have_content 'The User is successfully saved!'
</code></pre>

<p>  end
end
```</p>

<p>The test is pretty simple, we fill up the form with data, click 'Sign Up' button, and
expect to be redirected again to "Sign Up" page (in new post when we create a Login page
the <code>create</code> action will be redirecting to it!) and we expect that the flash notice will show that
User is successfully saved.</p>

<p>The test should fail on the clicking the <em>Sign Up</em> button, because there is no <code>create</code>
action in <code>UsersController</code>:</p>

<p>```
1) Users POST /users creates and saves the valid user
   Failure/Error: click_button 'Sign Up'
   AbstractController::ActionNotFound:</p>

<pre><code> The action 'create' could not be found for UsersController
</code></pre>

<p>```</p>

<p>So to pass this test we need to add a <code>create</code> method to the <code>UsersController</code>:</p>

<p>```ruby
def create
  @user = User.new params[:user]</p>

<p>  if @user.save</p>

<pre><code>flash[:notice] = 'The User is successfully saved!'
redirect_to signup_path
</code></pre>

<p>  end
end
```</p>

<p>First we storing a User to instance variable <code>@user</code> from the data given in User Sign Up
Form as <code>params[:user]</code>. Then we try to save it, and on success, we assign the flash notice
and redirect back to Sign Up Page.</p>

<p>The test should pass:</p>

<pre><code>Finished in 1.37 seconds
11 examples, 0 failures
</code></pre>

<p>The happy path is working, now lets test all the possible ways the Sign Up might go wrong!</p>

<h2>Invalid User Tests</h2>

<h3>Password Confirmation</h3>

<p>Lets first check <code>password</code>s matching is working, by applying the two different passwords.
We shall crate the new <code>context</code> inside <code>POST /users</code> <code>context</code> and call it "<em>not saving invalid user</em>":</p>

<p>```ruby
context 'not saving invalid user' do
  it 'when passwords mismatch' do</p>

<pre><code>visit new_user_path

fill_in 'Email', with: 'xajler@gmail.com'
fill_in 'Password', with: 'x1234567'
fill_in 'Confirm Password', with: 'x123'
fill_in 'Full Name', with: 'Kornelije Sajler'
click_button 'Sign Up'

current_path.should == signup_path
page.should have_content "Password doesn't match confirmation"
</code></pre>

<p>  end
end
```</p>

<p>After running test we shall get odd message that there is no View Template for <code>create</code>.</p>

<p>```
1) Users POST /users not saving invalid user when passwords mismatch
   Failure/Error: click_button 'Sign Up'
   ActionView::MissingTemplate:</p>

<pre><code> Missing template users/create, application/create with {:locale=&gt;[:en], :formats=&gt;[:html], :handlers=&gt;[:erb, :builder, :coffee, :haml]}. Searched in:
   * "/Users/xajler/src/rb/just-todo-it/app/views"
</code></pre>

<p>```</p>

<p>We don't need a new View Template but rather change the <code>UserController</code> method <code>create</code>
to do something if the user is not saved. And when is not saved we shall flash an error message:</p>

<p>```ruby
def create
  @user = User.new params[:user]</p>

<p>  if @user.save</p>

<pre><code>flash[:notice] = 'The User is successfully saved!'
redirect_to signup_path
</code></pre>

<p>  else</p>

<pre><code>flash[:error] = @user.errors.full_messages[0]
redirect_to signup_path
</code></pre>

<p>  end
end
```</p>

<p>We are setting as a flash message from a User instance errors and getting first <code>full_message</code>
that will be set upon having problem saving user and in this case message will be
"<em>Password doesn't match confirmation</em>".</p>

<p>After applying the given code, the test should pass:</p>

<pre><code>Finished in 1.54 seconds
12 examples, 0 failures
</code></pre>

<p>With this code applied we also satisfy the tests that are yet to come, but we still need
tests to prove that <code>create</code> method is working and proper error messages are thrown to
guide the users of Application to resolve them!</p>

<h3>Required Fields</h3>

<p>We have three required fields:</p>

<ul>
<li><code>email</code></li>
<li><code>password</code></li>
<li><code>full_name</code></li>
</ul>


<p>Lets write three more test, they should all be green since the implementation is written
to satisfy the previous test.</p>

<p>We will add them to the "<em>not saving invalid user</em>" <code>context</code> below the latest test:</p>

<p>```ruby
it 'when email is blank' do
  visit new_user_path</p>

<p>  fill_in 'Email', with: ''
  fill_in 'Password', with: 'x1234567'
  fill_in 'Confirm Password', with: 'x1234567'
  fill_in 'Full Name', with: 'Kornelije Sajler'
  click_button 'Sign Up'</p>

<p>  current_path.should == signup_path
  page.should have_content "Email can't be blank"
end</p>

<p>it 'when password is blank' do
  visit new_user_path</p>

<p>  fill_in 'Email', with: 'xajler@gmail.com'
  fill_in 'Password', with: ''
  fill_in 'Confirm Password', with: ''
  fill_in 'Full Name', with: 'Kornelije Sajler'
  click_button 'Sign Up'</p>

<p>  current_path.should == signup_path
  page.should have_content "Password digest can't be blank"
end</p>

<p>it 'when full name is blank' do
  visit new_user_path</p>

<p>  fill_in 'Email', with: 'xajler@gmail.com'
  fill_in 'Password', with: 'x1234567'
  fill_in 'Confirm Password', with: 'x1234567'
  fill_in 'Full Name', with: ''
  click_button 'Sign Up'</p>

<p>  current_path.should == signup_path
  page.should have_content "Full name can't be blank"
end
```</p>

<p>So, in first test we test required Email, by sending blank one. In second the Passwords
are blank and in third the Full Name is blank. And each test expect that meaningful messages
are shown to the user of application!</p>

<p>And if all was OK then all tests should pass:</p>

<pre><code>Finished in 1.79 seconds
15 examples, 0 failures
</code></pre>

<h3>Email Uniqueness</h3>

<p>The saving User with entered existing <code>email</code> should fail. Lets create the test to prove
it:</p>

<p>```ruby
it 'when email is not unique' do
  create :user
  visit new_user_path</p>

<p>  fill_in 'Email', with: 'xajler@gmail.com'
  fill_in 'Password', with: 'x1234567'
  fill_in 'Confirm Password', with: 'x1234567'
  fill_in 'Full Name', with: 'Kornelije Sajler'
  click_button 'Sign Up'</p>

<p>  current_path.should == signup_path
  page.should have_content 'Email has already been taken'
end
```</p>

<p>So, first we insert User from our created factory via <em>Factory Girl</em>. The factory of User
inserted has the same email that we try to save it from the User Sign Up Form. And again
we test to get meaningful message when email is not unique.</p>

<p>The test should pass, because the code is implemented:</p>

<pre><code>Finished in 2.02 seconds
16 examples, 0 failures
</code></pre>

<h3>Password with at least 8 characters</h3>

<p>The User cannot be saved if both passwords length is at least 8 characters long:</p>

<p>```ruby
it 'when password is less than 8 characters' do
  visit new_user_path</p>

<p>  fill_in 'Email', with: 'xajler@gmail.com'
  fill_in 'Password', with: '123'
  fill_in 'Confirm Password', with: '123'
  fill_in 'Full Name', with: 'Kornelije Sajler'
  click_button 'Sign Up'</p>

<p>  current_path.should == signup_path
  page.should have_content "Password is too short (minimum is 8 characters)"
end
```</p>

<p>The test applies the Passwords that are of 3 characters long and we expect to get right message
that is telling the right expectations of Password in this case minimum of 8 characters.</p>

<p>This was easy, all tests should pass still:</p>

<pre><code>Finished in 2.07 seconds
17 examples, 0 failures
</code></pre>

<blockquote><p>Note:</p>

<p>If you using <em>Guard</em> as I do, for running test, you may need to enter <code>r</code> command to
<em>Guard</em> console to reload all, only if your tests are passing and they should not be or vice versa!</p></blockquote>

<p>And with this test we have test for all User Create problems, now we'll add test for User Update.</p>

<h2>Valid Update Test</h2>

<p>Essentially, the valid update only lets to change User <code>password</code> and <code>full_name</code>. Create
new <code>context</code> called "<em>PUT users/:id</em>" and new <code>it</code> block "<em>valid user update</em>":</p>

<p>```ruby
context 'PUT users/:id' do
  it 'valid user update' do</p>

<pre><code>user = create :user
visit edit_user_path user

find_field('Email').value.should == 'xajler@gmail.com'
find_field('Full Name').value.should == 'Kornelije Sajler'

fill_in 'Email', with: 'xajler@gmail.com'
fill_in 'Password', with: 'aoeuidht'
fill_in 'Confirm Password', with: 'aoeuidht'
fill_in 'Full Name', with: 'Kornelije Sajler - xajler'
click_button 'Update User'

current_path.should == edit_user_path(user)
page.should have_content 'The User is successfully updated!'
</code></pre>

<p>  end
end
```</p>

<p>First we create a User from factory and save it as variable, because we are simulating edit,
so we need the User id when we want to edit him. This is why we pass the <code>user</code> variable to the
<code>edit_user_path</code>.</p>

<p>Before we fill in the User Update Form we shall test it if the Form fields are actually binded with
data from User that will be updated.</p>

<p>OK, same thing as for new/create it will fail, first, because there is no method <code>edit</code> in
<code>UsersController</code>.</p>

<p>```
1) Users POST /users PUT users/:id valid user update
   Failure/Error: visit edit_user_path #user
   ActionController::RoutingError:</p>

<pre><code> No route matches {:action=&gt;"edit", :controller=&gt;"users"}
</code></pre>

<p>```</p>

<p>To pass this error lets create the <code>edit</code> method:</p>

<p><code>ruby
def edit
  @user = User.find params[:id]
end
</code></p>

<p>So we need the User to get him from the given <em>params id</em> so that we can have it in
instance variable <code>@user</code> and share it to the View and then fill the form with existing
User data.</p>

<p>The test should still fail, because there is no edit View Template:</p>

<p>```
1) Users POST /users PUT users/:id valid user update
   Failure/Error: visit edit_user_path user
   ActionView::MissingTemplate:</p>

<pre><code> Missing template users/edit, application/edit with {:locale=&gt;[:en], :formats=&gt;[:html], :handlers=&gt;[:erb, :builder, :coffee, :haml]}. Searched in:
   * "/Users/xajler/src/rb/just-todo-it/app/views"
</code></pre>

<p>```</p>

<p>Long time ago when we are creating View Template for Sign Up we've created <code>new.html.haml</code>
and also separated form to partial <code>_form.html.haml</code> so it can be shared with Edit User View.</p>

<p>Lets create <code>edit.html.haml</code> View page that calls the Form partial and passing to it the
<code>@user</code> so that the Form will display User data:</p>

<p>```haml
%h1 Update User</p>

<p>= render partial: 'form', locals: { user: @user }
```</p>

<p>The test will fail because there is no button "Update User", and this is because we hard-coded
the "Sign Up" text to submit element in the form partial <code>_form.html.haml</code>. We will fix it now,
not very pretty but it will work:</p>

<p>Change <code>submit</code> in <code>_form.html.haml</code> from:</p>

<p><code>haml
= f.submit 'Sign Up'
</code>
To:</p>

<p><code>haml
= f.submit @user.id ? 'Update User' : 'Sign Up'
</code></p>

<p>The test should still fail because we are after all trying to update, and there in no
<code>update</code> method it <code>UsersController</code>:</p>

<p>```
1) Users POST /users PUT users/:id valid user update
   Failure/Error: click_button 'Update User'
   AbstractController::ActionNotFound:</p>

<pre><code> The action 'update' could not be found for UsersController
</code></pre>

<p>```</p>

<p>So, we shall impelment the <code>update</code> method for the <code>UsersController</code>:</p>

<p>```ruby
def update
  @user = User.find params[:id]</p>

<p>  if @user.update_attributes params[:user]</p>

<pre><code>flash[:notice] = 'The User is successfully updated!'
redirect_to edit_user_path
</code></pre>

<p>  end
end
```</p>

<p>First we getting User from the database from given User Id, and then call <code>update_atrributes</code>
from the data send via Form as <code>params[:user]</code>. Set the flash notice that User is updated
and redirect to Update User page where we can see that User is actually updated.</p>

<p>And at last the test is passing:</p>

<pre><code>Finished in 2.3 seconds
18 examples, 0 failures
</code></pre>

<p>The only problem here is that to Update User the <code>password</code>s needed to be entered every
time. There are better solutions, like if they are blank, to ignore them on update, instead
currently it will be validated. And blank password is not allowed!</p>

<h2>Password Mismatch</h2>

<p>We will not try all the tests that we tried for User Sign Up, but only one. If you remember,
this was the only test that was needed a code, others were just a proof of existing code,
that is more about User Model than actual User View, but we've needed to run them all to
ensure that flash messages are proper and expected.</p>

<p>```ruby
it 'invalid when passwords mismatch' do
  user = create :user
  visit edit_user_path user</p>

<p>  fill_in 'Email', with: 'xajler@gmail.com'
  fill_in 'Password', with: 'aoeuidht'
  fill_in 'Confirm Password', with: 'aoeu'
  fill_in 'Full Name', with: 'Kornelije Sajler'
  click_button 'Update User'</p>

<p>  current_path.should == edit_user_path(user)
  page.should have_content "Password doesn't match confirmation"
end
```</p>

<p>And the test fails, complaining about View, but actually we need the code in Controller,
to send message of what went wrong to User Update Form:</p>

<p>```ruby
def update
  @user = User.find params[:id]</p>

<p>  if @user.update_attributes params[:user]</p>

<pre><code>flash[:notice] = 'The User is successfully updated!'
redirect_to edit_user_path
</code></pre>

<p>  else</p>

<pre><code>  flash[:error] = @user.errors.full_messages[0]
  redirect_to edit_user_path
</code></pre>

<p>  end
end
```</p>

<p>After adding the else clause to <code>update</code> method that handles all errors, the test
should pass:</p>

<pre><code>Finished in 2.6 seconds
19 examples, 0 failures
</code></pre>

<h2>Ensure Email is not changed after User creation</h2>

<p>The only test that is left is to ensure that <code>email</code> given on create should never ever
be possible to change!</p>

<p>In this test we shall try to change the email of existing User and it needs to be the same
after update, even though the <code>email</code> sent to update is quite different from the one when
User is created:</p>

<p>```ruby
it 'keeps the User Email intact while other fields do change' do
  user = create :user
  visit edit_user_path user</p>

<p>  find_field('Email').value.should == 'xajler@gmail.com'
  find_field('Full Name').value.should == 'Kornelije Sajler'</p>

<p>  fill_in 'Email', with: 'xxx@example.com'
  fill_in 'Password', with: 'aoeuidht'
  fill_in 'Confirm Password', with: 'aoeuidht'
  fill_in 'Full Name', with: 'Kornelije Sajler - xajler'
  click_button 'Update User'</p>

<p>  current_path.should == edit_user_path(user)
  find_field('Email').value.should == 'xajler@gmail.com'
  find_field('Full Name').value.should == 'Kornelije Sajler - xajler'
end
```</p>

<p>The above test ensures that the <code>email</code> after creation will stay intact, while other fields
will change, there will be no errors having different <code>email</code>. The <code>email</code> for update will
be silently ignored.</p>

<p>The implementation code of this validation is actually in User Model,
making the <code>email</code> as <code>attr_readonly</code> that we did in previous post, this test only ensures
that validation is implemented from View perspective.</p>

<p>And now all 20 test should pass, and we use RSpec format to show them all:</p>

<p>```text
User
  #email must not ever change after it is created
  is valid
  is invalid</p>

<pre><code>when required #email is not given
when #email format is not valid
when #email is not unique
when required #full_name is not given
when required #password is not given
when #password is not at least 8 characters
</code></pre>

<p>Users
  GET /signup</p>

<pre><code>displays the sign up page
</code></pre>

<p>  PUT users/:id</p>

<pre><code>valid user update
invalid when passwords mismatch
keeps the User Email intact while other fields do change
</code></pre>

<p>  POST /users</p>

<pre><code>creates and saves the valid user
not saving invalid user
  when passwords mismatch
  when email is not unique
  when full name is blank
  when password is blank
  when email is blank
  when password is less than 8 characters
</code></pre>

<p>  GET /users/new</p>

<pre><code>displays the create new user page
</code></pre>

<p>Finished in 2.86 seconds
20 examples, 0 failures
```</p>

<h2>Users Controller</h2>

<p>The whole Users Controller <code>app/controllers/users_controllers.rb</code> after this post should look like this:</p>

<p>```ruby app/controllers/users_controllers.rb
class UsersController &lt; ApplicationController
  def new</p>

<pre><code>@user = User.new
</code></pre>

<p>  end</p>

<p>  def create</p>

<pre><code>@user = User.new params[:user]

if @user.save
  flash[:notice] = 'The User is successfully saved!'
  redirect_to signup_path
else
  flash[:error] = @user.errors.full_messages[0]
  redirect_to signup_path
end
</code></pre>

<p>  end</p>

<p>  def edit</p>

<pre><code>@user = User.find params[:id]
</code></pre>

<p>  end</p>

<p>  def update</p>

<pre><code>@user = User.find params[:id]

if @user.update_attributes params[:user]
  flash[:notice] = 'The User is successfully updated!'
  redirect_to edit_user_path
else
    flash[:error] = @user.errors.full_messages[0]
    redirect_to edit_user_path
end
</code></pre>

<p>  end
end
```</p>

<h2>Users Request Spec (Tests)</h2>

<p>The whole Users Request Spec <code>spec/requests/users_spec.rb</code> after this post should look like this:</p>

<p>```ruby spec/requests/users_spec.rb
require 'spec_helper'</p>

<p>describe 'Users' do
  context 'GET /users/new' do</p>

<pre><code>it 'displays the create new user page' do
  visit new_user_path

  page.should have_content 'Email'
  page.should have_content 'Full Name'
  page.should have_content 'Password'
  page.should have_content 'Confirm Password'
  page.has_field? 'email'
  page.has_field? 'full_name'
  page.has_field? 'password'
  page.has_field? 'password_confirmation'
  page.has_button? 'Sign Up'
end
</code></pre>

<p>  end</p>

<p>  context 'GET /signup' do</p>

<pre><code>it 'displays the sign up page' do
  visit signup_path

  page.should have_content 'Email'
  page.should have_content 'Full Name'
  page.should have_content 'Password'
  page.should have_content 'Confirm Password'
  page.has_field? 'email'
  page.has_field? 'full_name'
  page.has_field? 'password'
  page.has_field? 'password_confirmation'
  page.has_button? 'Sign Up'
end
</code></pre>

<p>  end</p>

<p>  context 'POST /users' do</p>

<pre><code>it 'creates and saves the valid user' do
  visit new_user_path

  fill_in 'Email', with: 'xajler@gmail.com'
  fill_in 'Password', with: 'x1234567'
  fill_in 'Confirm Password', with: 'x1234567'
  fill_in 'Full Name', with: 'Kornelije Sajler'
  click_button 'Sign Up'

  current_path.should == signup_path
  page.should have_content 'The User is successfully saved!'
end

context 'not saving invalid user' do
  it 'when passwords mismatch' do
    visit new_user_path

    fill_in 'Email', with: 'xajler@gmail.com'
    fill_in 'Password', with: 'x1234567'
    fill_in 'Confirm Password', with: 'x123'
    fill_in 'Full Name', with: 'Kornelije Sajler'
    click_button 'Sign Up'

    current_path.should == signup_path
    page.should have_content "Password doesn't match confirmation"
  end

  it 'when email is blank' do
    visit new_user_path

    fill_in 'Email', with: ''
    fill_in 'Password', with: 'x1234567'
    fill_in 'Confirm Password', with: 'x1234567'
    fill_in 'Full Name', with: 'Kornelije Sajler'
    click_button 'Sign Up'

    current_path.should == signup_path
    page.should have_content "Email can't be blank"
  end

  it 'when password is blank' do
    visit new_user_path

    fill_in 'Email', with: 'xajler@gmail.com'
    fill_in 'Password', with: ''
    fill_in 'Confirm Password', with: ''
    fill_in 'Full Name', with: 'Kornelije Sajler'
    click_button 'Sign Up'

    current_path.should == signup_path
    page.should have_content "Password digest can't be blank"
  end

  it 'when full name is blank' do
    visit new_user_path

    fill_in 'Email', with: 'xajler@gmail.com'
    fill_in 'Password', with: 'x1234567'
    fill_in 'Confirm Password', with: 'x1234567'
    fill_in 'Full Name', with: ''
    click_button 'Sign Up'

    current_path.should == signup_path
    page.should have_content "Full name can't be blank"
  end

  it 'when email is not unique' do
    create :user
    visit new_user_path

    fill_in 'Email', with: 'xajler@gmail.com'
    fill_in 'Password', with: 'x1234567'
    fill_in 'Confirm Password', with: 'x1234567'
    fill_in 'Full Name', with: 'Kornelije Sajler'
    click_button 'Sign Up'

    current_path.should == signup_path
    page.should have_content 'Email has already been taken'
  end

  it 'when password is less than 8 characters' do
    visit new_user_path

    fill_in 'Email', with: 'xajler@gmail.com'
    fill_in 'Password', with: '123'
    fill_in 'Confirm Password', with: '123'
    fill_in 'Full Name', with: 'Kornelije Sajler'
    click_button 'Sign Up'

    current_path.should == signup_path
    page.should have_content "Password is too short (minimum is 8 characters)"
  end
end
</code></pre>

<p>  end</p>

<p>  context 'PUT users/:id' do</p>

<pre><code>it 'valid user update' do
  user = create :user
  visit edit_user_path user

  find_field('Email').value.should == 'xajler@gmail.com'
  find_field('Full Name').value.should == 'Kornelije Sajler'

  fill_in 'Email', with: 'xajler@gmail.com'
  fill_in 'Password', with: 'aoeuidht'
  fill_in 'Confirm Password', with: 'aoeuidht'
  fill_in 'Full Name', with: 'Kornelije Sajler - xajler'
  click_button 'Update User'

  current_path.should == edit_user_path(user)
  page.should have_content 'The User is successfully updated!'
end

it 'invalid when passwords mismatch' do
  user = create :user
  visit edit_user_path user

  fill_in 'Email', with: 'xajler@gmail.com'
  fill_in 'Password', with: 'aoeuidht'
  fill_in 'Confirm Password', with: 'aoeu'
  fill_in 'Full Name', with: 'Kornelije Sajler'
  click_button 'Update User'

  current_path.should == edit_user_path(user)
  page.should have_content "Password doesn't match confirmation"
end

it 'keeps the User Email intact while other fields do change' do
  user = create :user
  visit edit_user_path user

  find_field('Email').value.should == 'xajler@gmail.com'
  find_field('Full Name').value.should == 'Kornelije Sajler'

  fill_in 'Email', with: 'xxx@example.com'
  fill_in 'Password', with: 'aoeuidht'
  fill_in 'Confirm Password', with: 'aoeuidht'
  fill_in 'Full Name', with: 'Kornelije Sajler - xajler'
  click_button 'Update User'

  current_path.should == edit_user_path(user)
  find_field('Email').value.should == 'xajler@gmail.com'
  find_field('Full Name').value.should == 'Kornelije Sajler - xajler'
end
</code></pre>

<p>  end
end
```</p>

<h2>Conclusion</h2>

<p>In this post we made sure that User Model Validation that is tested through actual User
Sign Up and Update Views. And all aspects of Validation are tested in integration Broweser
Tests simulated with <em>Capybara</em>.</p>

<p>In next post we shall finally tackle the Login page and implementing Authentication for
Application.</p>

<h2>Code</h2>

<p>The code is hosted on GitHub and can be cloned from the <a href="https://github.com/xajler/just-todo-it">xajler/just-todo-it</a>.</p>

<blockquote><p>Github xajler/just-todo-it commits for this post:</p>

<p><a href="https://github.com/xajler/just-todo-it/commit/ebbd2b0e48b3b6d94571f8d593d8d194bd6aec46">The User Create and Update Integration Tests, Users Controller and new Edit View Template.</a></p>

<p><a href="https://github.com/xajler/just-todo-it/commit/4da7186bd475e6465f35ee404b2c50b4bbfdf996">A PUT tests are now top context, not child of POST context tests.</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails App from Scratch: User Validation]]></title>
    <link href="http://learnaholic.me/2012/11/05/rails-app-from-scratch-user-validation/"/>
    <updated>2012-11-05T13:30:00+01:00</updated>
    <id>http://learnaholic.me/2012/11/05/rails-app-from-scratch-user-validation</id>
    <content type="html"><![CDATA[<p>On the last post we've created a User Sign Up page and in this post we'll continue to add
some validation to the User to make sure that User is valid so it is safe to save or update
User to the Database.</p>

<h2>Validation</h2>

<p>There are few rules that we've mention in last post about some validation logic:</p>

<ul>
<li><em>Email</em> - Required, Unique, valid email format and after creation it cannot be updated anymore or for short read-only.</li>
<li><em>Password</em> - Required and at least 8 characters long.</li>
<li><em>Full Name</em> - Required.</li>
</ul>


<h2>Validation for Required Attributes</h2>

<p>We had one pending test up till now in <code>spec/models/user_spec.rb</code>. We will use this test
file to set up the Validation for User in TDD way.</p>

<p>First remove pending part generated on User Model:</p>

<pre><code>pending "add some examples to (or delete) #{__FILE__}"
</code></pre>

<h3>User Factory</h3>

<p>First lets create a Factory of User that we'll use in tests. This will be a valid Model of User:</p>

<p>```ruby
FactoryGirl.define do
  factory :user do</p>

<pre><code>email 'xajler@gmail.com'
password 'x1234567'
password_confirmation 'x1234567'
full_name 'Kornelije Sajler'
</code></pre>

<p>  end
end
```</p>

<h3>RSpec let and subject and Factory Girl build</h3>

<p>Then we'll learn some of RSpec and Factory Girl, but first add this beneath the <code>describe</code> block:</p>

<p>```ruby
let :user do
  build :user
end</p>

<p>subject do
 user
end
```</p>

<p>RSpec <code>let</code> description borrowed from the RSpec documentation:</p>

<blockquote><p>Use let to define a memoized helper method. The value will be cached across multiple calls in the same example but not across examples.</p>

<p>Note that let is lazy-evaluated: it is not evaluated until the first time the method it defines is invoked. You can use let! to force the method's invocation before each example.</p></blockquote>

<p>RSpec <code>subject</code></p>

<blockquote><p>Use subject in the group scope to explicitly define the value that is returned by the subject method in the example scope.</p></blockquote>

<p>There is also used a Factory Girl <code>build</code> that returns a User instance that's not saved, use <code>create</code>
if it is mandatory that Model is saved to database before getting it in tests.</p>

<h3>Required Fields Model Tests</h3>

<p>The <code>email</code>, <code>password</code> and <code>full_name</code> are required so we create the RSpec <code>context</code> named
<em>is invalid</em> and even though we should go one by one test for each attribute, for quickness we'll
do them at once:</p>

<p>```ruby
context 'is invalid' do
  it 'when required #email is not given' do</p>

<pre><code>user.email = ''
should_not be_valid
</code></pre>

<p>  end</p>

<p>  it 'when required #password is not given' do</p>

<pre><code>user.password = ''
should_not be_valid
</code></pre>

<p>  end</p>

<p>  it 'when required #full_name is not given' do</p>

<pre><code>user.full_name = ''
should_not be_valid
</code></pre>

<p>  end
end
```</p>

<blockquote><p>Note:</p>

<p>The <code>#</code> is used to denote the Ruby way of describing the <em>instance methods</em>, the <code>.</code> is
used for the <em>class methods</em>!</p></blockquote>

<p>The <code>should_not</code> can be used since we set a <code>subject</code> to be instance of User built from
Factory Girl <code>:user</code> factory so the RSpec knows to what the <code>should_not</code> refers to.</p>

<p>The <code>be_valid</code> method is a RSpec shorthand for the Rails <code>valid?</code> method that returns
boolean hence the <code>?</code>, every Ruby method with <code>?</code> can be called in RSpec with <code>be_&lt;name_of_method&gt;</code>.</p>

<p>The running tests should failing with message:</p>

<p>```
Failures:</p>

<p>  1) User is invalid when required #full_name is not given</p>

<pre><code> Failure/Error: should_not be_valid
   expected valid? to return false, got true
</code></pre>

<p>  2) User is invalid when required #email is not given</p>

<pre><code> Failure/Error: should_not be_valid
   expected valid? to return false, got true
</code></pre>

<p>  3) User is invalid when required #password is not given</p>

<pre><code> Failure/Error: should_not be_valid
   expected valid? to return false, got true
</code></pre>

<p>```</p>

<p>To make the test green, add the <code>validates presence</code> for all three required properties
in the <code>app/models/user.rb</code>:</p>

<p>```ruby app/models/user.rb
class User &lt; ActiveRecord::Base
  has_secure_password</p>

<p>  attr_accessible :email, :password, :password_confirmation, :full_name</p>

<p>  validates :email, presence: true
  validates :password, presence: true
  validates :full_name, presence: true
end
```</p>

<p>The tests should all pass:</p>

<pre><code>Finished in 0.81772 seconds
5 examples, 0 failures
</code></pre>

<h2>Validation of Email Uniqueness</h2>

<p>Another validation for <code>email</code> is that is need to be unique or there should not be two same
<code>email</code>s stored in the database.</p>

<p>Add the new <code>it</code> test to <code>spec/models/user_spec.rb</code> in <em>is invalid</em> <code>context</code>:</p>

<p>```ruby
it 'when #email is not unique' do
  user.save
  user1 = build :user
  user1.save</p>

<p>  user1.should_not be_valid
  user1.errors.full_messages[0].should match 'Email has already been taken'
end
```</p>

<p>This test is little sketchy, firstly because there are two assertions and secondly of
saving our <code>subject</code> User, then <code>build</code> identical User, store him to <code>user1</code> variable, and
then try to save User to database.</p>

<p>The second assertion is just to make sure that error is raised because of the <code>email</code> uniqueness.</p>

<p>The failing message:</p>

<p>```
1) User is invalid when #email is not unique
   Failure/Error: user1.should_not be_valid</p>

<pre><code> expected valid? to return false, got true
</code></pre>

<p>```</p>

<p>So the only thing is for us to prevent having <code>email</code> stored to database more than once
with <code>uniqueness</code> added to existing <code>email vaildates</code>:</p>

<p><code>ruby
validates :email, presence: true, uniqueness: true
</code>
This should make the test green:</p>

<pre><code>Finished in 0.8653 seconds
6 examples, 0 failures
</code></pre>

<h2>Validation of Email format</h2>

<p>Next there is need to make sure that the <code>email</code> format is valid. The <em>Regular Expression</em>
is used to validate the <code>email</code> format.</p>

<blockquote><p><strong>Note</strong>: There are better ways to do the complex Mail validation in Ruby or Rails, but it is out of scope of this simple app!</p></blockquote>

<p>Add test below latest one, still in the <em>is invalid</em> <code>context</code>:</p>

<p><code>ruby
it 'when #email format is not valid' do
  user.email = 'invalid mail'
  should_not be_valid
end
</code>
The test should fail with message:</p>

<p>```
1) User is invalid when #email format is not valid
   Failure/Error: should_not be_valid</p>

<pre><code> expected valid? to return false, got true
</code></pre>

<p>```</p>

<p>To fix it simple as possible add the <code>format</code> to <code>email validates</code>:</p>

<p>```ruby
validates :email, presence: true, uniqueness: true,</p>

<pre><code>      format: { with: /\A[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]+\z/,
                message: 'The format of Email is invalid'}
</code></pre>

<p>```</p>

<p>This should make to pass the test:</p>

<p><code>
Finished in 1.3 seconds
7 examples, 0 failures
</code></p>

<h2>Validation of at least 8 chars for Password</h2>

<p>The User entered <code>password</code> must be at least 8 characters.
The <code>password</code> will also be simple as possible without checking that there are at least
one number or symbol, but rather, just to have at least 8 characters!</p>

<p>Add new test as last in <code>context</code> <em>is invalid</em>:</p>

<p><code>ruby
it 'when #password is not at least 8 characters' do
  user.password = 'abc123'
  should_not be_valid
end
</code></p>

<p>The test should fail with message:</p>

<p>```
1) User is invalid when #password is not at least 8 characters
   Failure/Error: should_not be_valid</p>

<pre><code> expected valid? to return false, got true
</code></pre>

<p>```</p>

<p>To make test pass add the <code>length</code> to the <code>password validates</code>:</p>

<p><code>ruby
validates :password, presence: true, length: { minimum: 8 }
</code></p>

<p>The test should pass now:</p>

<pre><code>Finished in 1.09 seconds
8 examples, 0 failures
</code></pre>

<h2>The Email must be read-only</h2>

<p>The <code>email</code> can only be set when is created and after saving to the database that <code>email</code>
must not ever be possible to change.</p>

<p>Outside of the <code>context</code> <em>is invalid</em> create the new <code>it</code> test:</p>

<p><code>ruby
it '#email must not ever change after it is created' do
  user.save
  user.update_attributes email: 'ksajler@gmail.com'
  user.reload.email.should eql 'xajler@gmail.com'
end
</code></p>

<p>This test is a little bit weird, what it ensures that when attributes are updated and
reloaded from the database, that the <code>email</code> is still same as when it was created even
though is changed to new value.</p>

<p>The test should fail with message:</p>

<p>```
1) User#email must not ever change after it is created
   Failure/Error: user.reload.email.should match 'xajler@gmail.com'</p>

<pre><code> expected "ksajler@gmail.com" to match "xajler@gmail.com"
</code></pre>

<p>```</p>

<p>To make sure that <code>email</code> is never changed after creation and all attempts to change the
<code>email</code> will be silently ignored, use Rails <code>attr_readonly</code> for <code>email</code>.</p>

<p>Then the <code>app/models/user.rb</code> should look like this:</p>

<p>```ruby app/models/user
class User &lt; ActiveRecord::Base
  has_secure_password</p>

<p>  attr_accessible :email, :password, :password_confirmation, :full_name
  attr_readonly :email</p>

<p>  validates :email, presence: true, uniqueness: true,</p>

<pre><code>        format: { with: /\A[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]+\z/,
                  message: 'The format of Email is invalid'}
</code></pre>

<p>  validates :password, presence: true, length: { minimum: 8 }
  validates :full_name, presence: true
end
```</p>

<p>And the test should pass:</p>

<pre><code>Finished in 1.28 seconds
9 examples, 0 failures
</code></pre>

<h2>Test that User is valid</h2>

<p>We tested all invalid combinations of the User to make sure that the logic we wanted is
implemented, now for sanity check we'll add the test to make sure when all given is valid
then the User should be valid and saving of the User can be executed.</p>

<p>Add new test <code>is valid</code> and the whole <code>spec/models/user_spec.rb</code> should look like this:</p>

<p>```ruby spec/models/user_spec.rb
require 'spec_helper'</p>

<p>describe User do
  let :user do</p>

<pre><code>build :user
</code></pre>

<p>  end</p>

<p>  subject do
   user
  end</p>

<p>  context 'is invalid' do</p>

<pre><code>it 'when required #email is not given' do
  user.email = ''
  should_not be_valid
end

it 'when required #password is not given' do
  user.password = ''
  should_not be_valid
end

it 'when required #full_name is not given' do
  user.full_name = ''
  should_not be_valid
end

it 'when #email is not unique' do
  user.save
  user1 = build :user
  user1.save

  user1.should_not be_valid
  user1.errors.full_messages[0].should match 'Email has already been taken'
end

it 'when #email format is not valid' do
  user.email = 'invalid mail'
  should_not be_valid
end

it 'when #password is not at least 8 characters' do
  user.password = 'abc123'
  should_not be_valid
end
</code></pre>

<p>  end</p>

<p>  it '#email must not ever change after it is created' do</p>

<pre><code>user.save
user.update_attributes email: 'ksajler@gmail.com'
user.reload.email.should match 'xajler@gmail.com'
</code></pre>

<p>  end</p>

<p>  it 'is valid' do</p>

<pre><code>should be_valid
</code></pre>

<p>  end
end
```</p>

<p>And all 10 tests, Integration and Model should pass:</p>

<pre><code>Finished in 1.24 seconds
10 examples, 0 failures
</code></pre>

<h2>Prettier RSpec Tests</h2>

<p>By default the RSpec tests are represented as dots (<code>.</code>) if they are passed and <code>F</code> if they fail.</p>

<p>To display <code>describe</code>, <code>context</code> and <code>it</code> titles while running RSpec, add <code>format</code> to
<code>.rspec</code> file:</p>

<p><code>text .rspec
--color
--format documentation
</code></p>

<p>Run all test and the format of RSpec test should look like this:</p>

<p>```text
User
  #email must not ever change after it is created
  is valid
  is invalid</p>

<pre><code>when #password is not at least 8 characters
when required #password is not given
when #email format is not valid
when required #full_name is not given
when #email is not unique
when required #email is not given
</code></pre>

<p>Users
  GET /users/new</p>

<pre><code>displays the create new user page
</code></pre>

<p>  GET /signup</p>

<pre><code>displays the sign up page
</code></pre>

<p>Finished in 1.81 seconds
10 examples, 0 failures
```</p>

<h2>Conclusion</h2>

<p>This post was all about the Rails Validation, there are few interesting samples how to
test Rails application. The TDD in this post is solely done on User Model instead of on
request browser based testes done with <em>Capybara</em>.</p>

<p>Now when we are sure that User Model validation logic is implemented and tested in next
post, we will Save and Update User Views, Controller methods and create browser based
test to make sure that User Model logic actually works in real usage!</p>

<h2>Code</h2>

<p>The code is hosted on GitHub and can be cloned from the <a href="https://github.com/xajler/just-todo-it">xajler/just-todo-it</a>.</p>

<blockquote><p>Github xajler/just-todo-it commit for this post:</p>

<p><a href="https://github.com/xajler/just-todo-it/commit/f2edd5551c915bba59b3aabb8c894325cf4f5414">Implemented User Model validation and tested in user_spec.rb, the tests using users factory.</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails App from Scratch: User Sign Up page]]></title>
    <link href="http://learnaholic.me/2012/10/24/rails-app-from-scratch-user-signup-page/"/>
    <updated>2012-10-24T05:25:00+02:00</updated>
    <id>http://learnaholic.me/2012/10/24/rails-app-from-scratch-user-signup-page</id>
    <content type="html"><![CDATA[<p>The aim of post is to create only the User Sign Up Page through TDD cycle of creating User
Resource, Controller, Model and View.</p>

<p>The <code>User</code> Model will be very simple having only:</p>

<ul>
<li><em>Email</em> - required, update is disabled once it is created.</li>
<li><em>Password</em> - required, should be greater or equal than 8 characters.</li>
<li><em>Full Name</em> - required, just for human readable displaying of the user name instead of email.</li>
</ul>


<blockquote><p>Note:</p>

<p>The first intention of this blog post was full User authentication, but since it uses
TDD step-by-step development, and there is a lot from creating Route, Controller, Model and View
this post will be only creating Sign Up page. Second and maybe third post will have
validation, saving, authenticating and updating user!</p></blockquote>

<h2>Generate User Integration Test</h2>

<p>First we will start with generating Rails <code>integration_test</code> residing in <code>spec/requests</code> folder:</p>

<p>```bash
$ rails g integration_test users</p>

<pre><code>  invoke  rspec
  create    spec/requests/users_spec.rb
</code></pre>

<p>```</p>

<p>First we will remove a <code>GET /users</code> as <code>describe</code> block generated by default in <code>spec/requests/users_spec.rb</code>
and left simple as:</p>

<p>```ruby spec/requests/users_sepec.rb
require 'spec_helper'</p>

<p>describe 'Users' do
end
```</p>

<h2>Create User Test</h2>

<p>In the <code>users_spec.rb</code> we will add a <code>context</code> block that will call the <code>new</code> route and
expect to have fields for <code>email</code>, <code>password</code>, <code>password_confirmation</code>, <code>full_name</code> and button <code>Sign Up</code>:</p>

<p>```ruby spec/requests/users_sepec.rb
require 'spec_helper'</p>

<p>describe 'Users' do
  context 'GET /users/new' do</p>

<pre><code>it 'displays the create new user page' do
  visit new_user_path

  page.should have_content 'Email'
  page.should have_content 'Full Name'
  page.should have_content 'Password'
  page.should have_content 'Confirm Password'
  page.has_field? 'email'
  page.has_field? 'full_name'
  page.has_field? 'password'
  page.has_field? 'password_confirmation'
  page.has_button? 'Sign Up'
end
</code></pre>

<p>  end
end
```
There are quite few asserts in this test, that is certainly not good practice in testing,
but to make this post shorter, it is like this!</p>

<h2>TDD Step 1: Routing (Resource)</h2>

<p>After running <em>RSpec</em> test or viewing from <code>Guard</code> the expected error on saving file should be:</p>

<p>```text
1) Users GET /users/new displays the create new user page
   Failure/Error: visit new_user_path
   NameError:</p>

<pre><code> undefined local variable or method `new_user_path' for #&lt;RSpec::Core::ExampleGroup::Nested_1::Nested_1:0x007fcf4a5a30b8&gt;
</code></pre>

<p>   # ./spec/requests/users_spec.rb:6:in `block (3 levels) in <top (required)>'
```</p>

<p>The problem is that there is no users route created.
Open <code>config/routes.rb</code>, remove all commented code and add <code>users</code> resource:</p>

<p><code>ruby config/routes.rb
JustToDoIt::Application.routes.draw do
  resources :users
end
</code></p>

<p>After run command to examine <em>Rails</em> routes:</p>

<p>```bash
$ rake routes</p>

<pre><code>users GET    /users(.:format)          users#index
      POST   /users(.:format)          users#create
</code></pre>

<p> new_user GET    /users/new(.:format)      users#new
edit_user GET    /users/:id/edit(.:format) users#edit</p>

<pre><code> user GET    /users/:id(.:format)      users#show
      PUT    /users/:id(.:format)      users#update
      DELETE /users/:id(.:format)      users#destroy
</code></pre>

<p>```</p>

<p>You will see the <code>new_user</code> path, but to actually get the path it is needed to be called
with <code>_path</code> added to the route name as we called it in first test <code>visit new_user_path</code>.</p>

<p>For this simple authentication we will only need creating and updating of user account,
but in future, we may need, a full administration of users, including listing all and destroy
them as well!</p>

<h3>Guard Routing Error</h3>

<p>If there is a <code>LoadError</code> after applying the route in <em>Guard</em> terminal:</p>

<p><code>
Exception encountered: #&lt;LoadError: cannot load such file -- /Users/xajler/src/rb/just-todo-it/spec/routing&gt;
</code></p>

<p>Create a <code>spec/routing</code> folder, to fix the issue:</p>

<p><code>bash
$ mkdir spec/routing
</code></p>

<p>After applying the user route (and <em>Guard</em> fix), there is a expected message complaining
for existence of users controller.</p>

<h2>TDD Step 2: Controller</h2>

<p>To make test green, we need to create a user controller and the action or method called <code>new</code>
in the <code>app/controllors/users_controller.rb</code>:</p>

<p>```ruby app/controllers/users_controller.rb
class UsersController &lt; ApplicationController
  def new</p>

<pre><code>@user = User.new
</code></pre>

<p>  end
end
```</p>

<p>We are creating a new <code>User</code> and setting it to a instance variable <code>@user</code>, so it will be
visible within the View page!</p>

<p>The RSpec test will be failing since it doesn't know what the <code>User</code> is:</p>

<p>```
1) Users GET /users/new displays the create new user page
   Failure/Error: visit new_user_path
   NameError:</p>

<pre><code> uninitialized constant UsersController::User
</code></pre>

<p>```</p>

<h2>TDD Step 3: Model</h2>

<p>To make test green, we need to create a <code>User</code> model in <code>app/models</code> and it will have
<code>email</code>, <code>passmord_digest</code> and <code>full_name</code>.</p>

<p>Having a <code>password_digest</code> field is important as it's the default name that's used with Rails
<code>has_secure_password</code> feature and we'll be using this feature later.</p>

<p>Use this command to generate User:</p>

<p>```bash
$ rails g model User email password_digest full_name</p>

<pre><code>  invoke  active_record
  create    db/migrate/20121023234400_create_users.rb
  create    app/models/user.rb
  invoke    rspec
  create      spec/models/user_spec.rb
  invoke      factory_girl
  create        spec/factories/users.rb
</code></pre>

<p>```</p>

<p>Change the generate <code>attr_accessible</code> to include  <code>email</code>, <code>password</code>, <code>password_confirmation</code>
and <code>full_name</code> needed for user create and edit form:</p>

<p>```ruby app/models/user.rb
class User &lt; ActiveRecord::Base
  has_secure_password</p>

<p>  attr_accessible :email, :password, :password_confirmation, :full_name
end
```</p>

<p>We also added <code>has_secure_password</code> to the User model. This was introduced in Rails 3.1
and adds some simple authentication support to the model using that <code>password_digest</code> column.</p>

<blockquote><p>Note:</p>

<p>To have this <code>bcrypt-ruby</code> gem must be in <code>Gemfile</code> (we included it in first post)
as this gem handles hashing the password before its stored in the database.</p></blockquote>

<p>The generator will create a Model, Migration, RSpec test and
a Factory Girl factory since we use it instead default Rails fixtures!</p>

<p>We will have another error regarding database:</p>

<p>```
1) Users GET /users/new displays the create new user page
   Failure/Error: visit new_user_path
   ActiveRecord::StatementInvalid:</p>

<pre><code> Could not find table 'users'
</code></pre>

<p>```</p>

<h3>Migration</h3>

<p>To have a database and make green our test, run command:</p>

<p><code>bash
$ rake db:migrate
==  CreateUsers: migrating ====================================================
-- create_table(:users)
   -&gt; 0.0025s
==  CreateUsers: migrated (0.0027s) ===========================================
</code></p>

<blockquote><p>Note:</p>

<p>This migration will create <code>development.sqlite3</code> <em>SQLite 3</em> database in <code>db</code> folder and <code>users</code> table.</p></blockquote>

<p>We also need to prepare database for testing with:</p>

<p><code>bash
$ rake db:test:prepare
</code></p>

<blockquote><p>Note:</p>

<p>This migration will create <code>test.sqlite3</code> <em>SQLite 3</em> database in <code>db</code> folder, and <code>users</code> table.</p></blockquote>

<p>The RSpec test still will be failing with complaint on not having a view for user:</p>

<p>```
1) Users GET /users/new displays the create new user page
   Failure/Error: visit new_user_path
   ActionView::MissingTemplate:</p>

<pre><code> Missing template users/new, application/new with {:locale=&gt;[:en], :formats=&gt;[:html], :handlers=&gt;[:erb, :builder, :coffee, :haml]}. Searched in:
   * "/Users/xajler/src/rb/just-todo-it/app/views"
</code></pre>

<p>```</p>

<h2>TDD Step 4: View</h2>

<p>As we noted in first tutorial, instead of default <em>Template View Engine</em> <code>erb</code>, we will use
far more better <code>haml</code> View Engine.</p>

<h3>Converting the erb layout to haml</h3>

<p>But before using the <code>haml</code> View Engine we need to convert default layout generated with
application:</p>

<p>```erb app/views/layouts/application.html.erb
&lt;!DOCTYPE html>
<html>
<head>
  <title>JustToDoIt</title>
  &lt;%= stylesheet_link_tag    "application", :media => "all" %>
  &lt;%= javascript_include_tag "application" %>
  &lt;%= csrf_meta_tags %>
</head>
<body></p>

<p>&lt;%= yield %></p>

<p></body>
</html>
```</p>

<p>to much more readable <code>haml</code> default layout for application:</p>

<p>```haml app/views/layouts/application.html.haml
!!! 5
%html
%head
  %title JustToDoIt
  = stylesheet_link_tag    'application', media: 'all'
  = javascript_include_tag 'application'
  = csrf_meta_tags</p>

<p>%body
  = yield
```</p>

<h3>New User View page</h3>

<p>We need to create a view for user called <code>new</code>, and it needs to have a fields for <code>email</code>,
<code>full_name</code>, <code>password</code>, <code>confirm password</code> and <code>Sign Up</code> button.</p>

<p>Create a <code>app/views/users/new.html.haml</code>:</p>

<p>```haml app/views/users/new.html.haml
%h1 Sign Up</p>

<p>= render partial: 'form'
```</p>

<h3>User Form Partial</h3>

<p>Since the creating and updating User form will be identical, we shall create a <code>partial</code> to reuse
user form on create and update views:</p>

<p>```haml app/views/users/_form.html.haml
= form_for @user do |f|
  - if @user.errors.any?</p>

<pre><code>%div.error_messages
  %h2 Form is invalid
  %ul
    - @user.errors.full_messages.each do |message|
      %li= message
</code></pre>

<p>  = f.label :email, 'Email:'
  = f.text_field :email
  %br</p>

<p>  = f.label :password, 'Password:'
  = f.text_field :password
  %br</p>

<p>  = f.label :password_confirmation, 'Confirm Password:'
  = f.text_field :password_confirmation
  %br</p>

<p>  = f.label :full_name, 'Full Name:'
  = f.text_field :full_name
  %br</p>

<p>  = f.submit 'Sign Up'
```</p>

<p>And finally the test will be green, ignore for now that <code>spec/models/user_spec.rb</code> is currently pending!</p>

<h2>Testing Sign Up Page with Browser</h2>

<p>The beauty of it all, is that we didn't even start browser, so we can do it now for test by running
Rails server (<em>Thin</em>):</p>

<p>```bash
$ rails s
=> Booting Thin
=> Rails 3.2.8 application starting in development on http://0.0.0.0:3000
=> Call with -d to detach
=> Ctrl-C to shutdown server</p>

<blockquote><blockquote><p>Thin web server (v1.5.0 codename Knife)
Maximum connections set to 1024
Listening on 0.0.0.0:3000, CTRL+C to stop
```</p></blockquote></blockquote>

<p>Open page:</p>

<pre><code>http://localhost:3000/users/new
</code></pre>

<p>The design it is not really attractive at all, but it was not scope of the post, and should
not be while creating application. When designers create full design it can be applied very
easily. Functionality matters for now!</p>

<h2>Creating the SignUp route</h2>

<p>The <code>/users/new</code> route name is descriptive but having just <code>/signup</code>, I think is far more
better route name!</p>

<h3>SignUp Route Test</h3>

<p>Create a new test context in <code>spec/resources/users_spec.rb</code>:</p>

<p>```ruby spec/requests/users_sepec.rb
require 'spec_helper'</p>

<p>describe 'Users' do
  context 'GET /users/new' do</p>

<pre><code>it 'displays the create new user page' do
  visit new_user_path

  page.should have_content 'Email'
  page.should have_content 'Full Name'
  page.should have_content 'Password'
  page.should have_content 'Confirm Password'
  page.has_field? 'email'
  page.has_field? 'full_name'
  page.has_field? 'password'
  page.has_field? 'password_confirmation'
  page.has_button? 'Sign Up'
end
</code></pre>

<p>  end</p>

<p>  context 'GET /signup' do</p>

<pre><code>it 'displays the sign up page' do
  visit signup_path

  page.should have_content 'Email'
  page.should have_content 'Full Name'
  page.should have_content 'Password'
  page.should have_content 'Confirm Password'
  page.has_field? 'email'
  page.has_field? 'full_name'
  page.has_field? 'password'
  page.has_field? 'password_confirmation'
  page.has_button? 'Sign Up'
end
</code></pre>

<p>  end
end
```</p>

<p>The <code>GET /signup</code> context is added that is now visiting the <code>signup_path</code>!</p>

<p>Test fails:</p>

<p>```
1) Users GET /signup displays the sign up page
   Failure/Error: visit signup_path
   NameError:</p>

<pre><code> undefined local variable or method `signup_path' for #&lt;RSpec::Core::ExampleGroup::Nested_1::Nested_2:0x007f9f8b6459d8&gt;
</code></pre>

<p>```</p>

<p>There is no <code>signup_path</code> so we need to create it in <code>routes</code>:</p>

<p><code>ruby config/routes.rb
JustToDoIt::Application.routes.draw do
  resources :users
  get 'signup', to: 'users#new', as: 'signup'
end
</code></p>

<p>The test passes and it is green, you can now try testing it in browser:</p>

<pre><code>localhost:3000/signup
</code></pre>

<p>It should work just fine!</p>

<h2>Conclusion</h2>

<p>This post intended to absorb whole authentication of user, but currently is just too long
and I will stop here and in second post will introduce validation, saving and maybe yet
in third post authenticating and updating user!</p>

<h2>Code</h2>

<p>The code is hosted on GitHub and can be cloned from the <a href="https://github.com/xajler/just-todo-it">xajler/just-todo-it</a>.</p>

<blockquote><p>Github xajler/just-todo-it commit for this post:</p>

<p><a href="https://github.com/xajler/just-todo-it/commit/7ee07ec64ca652f4840da8463ad3ce0d1efe64c6">Created User Controller, Model and View for Sign Up or Create User, created two integration tests, changed spec_helper due issues between the database_cleaner and sprok.</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails App from Scratch: Create and Configure for Testing]]></title>
    <link href="http://learnaholic.me/2012/10/19/rails-app-from-scratch-create-and-configure-testing/"/>
    <updated>2012-10-19T06:28:00+02:00</updated>
    <id>http://learnaholic.me/2012/10/19/rails-app-from-scratch-create-and-configure-testing</id>
    <content type="html"><![CDATA[<p>This blog post will be one many showing how to create <em>Todo</em> the <em>Rails 3</em> application.
The first post will be creating the Rails application and setting up the testing environment.</p>

<p> The app will be called <em>Just ToDo it</em>, just as famous
 <a href="https://en.wikipedia.org/wiki/Just_Do_It_(Nike)" target="_blank">Nike slogan</a>. And also Gods of DNS where
 good to me so the <em>Domain</em> <code>justtodoit.com</code> is free so I bought it and the final stage of this
 Rails posts will be deployment to <em>VPS</em> and pointing to the domain <a href="http://justtodoit.com">JustToDoIt</a>
 (Currently displays my domain <a href="http://metaintellect.com">metaintellect</a>).</p>

<h2>Create application</h2>

<p>The command to create new Rails application and omitting default testing framework <em>Unit::Test</em>
with switch <code>-T</code> or longer version is <code>--skip-test-unit</code></p>

<p><code>bash
$ rails new JustToDoIt -T
create
create  README.rdoc
create  Rakefile
create  config.ru
create  .gitignore
create  Gemfile
create  app
...
</code></p>

<p>I had capitalized <code>JustToDoIt</code> before, because the name is used as Ruby class and Pascal case is convention
for Ruby classes.</p>

<p>Then rename folder to <code>just-todo-it</code> to be more in *nix folder naming convention:</p>

<p><code>bash
$ mv JustToDoIt just-todo-it
</code></p>

<p>The fun starts when the directory is changed to Rails app directory:</p>

<p><code>bash
$ cd just-todo-it
</code></p>

<h2>Text editor</h2>

<p>I'll use <em>vim</em> as a default text editor, for <em>TextMate</em> use <code>mate</code> and for the <em>Sublime Text 2</em> use
<code>subl</code> terminal commands for editing files instead of <code>vim</code>.</p>

<h2>Gemfile</h2>

<p>First open the <code>Gemfile</code>, we need to add some <em>gems</em> that will be used in the app and also
for testing:</p>

<p><code>bash
$ vim Gemfile
</code>
Edit it to include this gems:</p>

<p>```ruby Gemfile
source 'https://rubygems.org'</p>

<p>gem 'rails'
gem 'bcrypt-ruby'
gem 'unicorn'
gem 'haml'
gem 'thin'
gem 'pg'</p>

<p>group :test, :development do
  gem 'sqlite3'
  gem 'rspec-rails'
  gem 'pry'
  gem 'factory_girl_rails'
  gem 'database_cleaner'
  gem 'awesome_print'
  gem 'capybara'
  gem 'rb-fsevent', :require => false if RUBY_PLATFORM =~ /darwin/i
  gem 'guard-rspec'
  gem 'spork'
  gem 'guard-spork'
end</p>

<p>group :assets do
  gem 'sass-rails',   '~> 3.2.3'
  gem 'coffee-rails', '~> 3.2.1'
  gem 'uglifier', '>= 1.0.3'
end</p>

<p>gem 'jquery-rails'
```</p>

<p>After changing the <code>Gemfile</code> run <em>bundler</em> to update and download entered <em>gems</em>:</p>

<p><code>bash
$ bundle install
</code></p>

<h3>Main and Production Ruby Gems</h3>

<ul>
<li><a href="http://rubyonrails.org/">rails</a> - The latest one <code>3.2.8</code> for this time of writing.</li>
<li><a href="https://github.com/codahale/bcrypt-ruby">bcrypt-ruby</a> - Needed for password hashing.</li>
<li><a href="https://github.com/defunkt/unicorn">unicorn</a> - For production, it will run as <a href="https://github.com/rack/rack">Rack</a> HTTP Server.</li>
<li><a href="http://haml.info/">haml</a> - My favorite View rendering engine.</li>
<li><a href="http://code.macournoyer.com/thin/">thin</a> - <em>Thin</em> as local server instead of default <em>Webrick</em>.</li>
<li><a href="https://bitbucket.org/ged/ruby-pg">pg</a> - My default database for production usage.</li>
</ul>


<h3>Test and Development Ruby Gems</h3>

<ul>
<li><a href="https://github.com/luislavena/sqlite3-ruby">sqlite3</a> - The database used for development and testing environments.</li>
<li><a href="https://www.relishapp.com/rspec/rspec-rails/docs">rspec-rails</a> - RSpec as default testing framework.</li>
<li><a href="http://pryrepl.org/">pry</a> - Using as default <em>Interactive Ruby</em> console instead of <code>irb</code>. Needs some configuration to be hooked as <code>rails console</code>.</li>
<li><a href="https://github.com/thoughtbot/factory_girl/blob/master/GETTING_STARTED.md">factory_girl_rails</a> - The testing factory framework, used instead of the default <em>Fixtures</em>.</li>
<li><a href="https://github.com/bmabey/database_cleaner">database_cleaner</a> - Used to speed-up tests, in my case to encapsulate the tests into db transaction.</li>
<li><a href="https://github.com/michaeldv/awesome_print">awesome_print</a> - Used by <em>Pry</em> to pretty prints Ruby objects in full color exposing their internal structure with proper indentation.</li>
<li><a href="http://jnicklas.github.com/capybara/">capybara</a> - for simulating the web interaction in the tests.</li>
<li><a href="https://github.com/guard/guard-rspec">guard-rspec</a> - To refresh and run the tests upon saving via <a href="https://github.com/thibaudgg/rb-fsevent">rb-fsevent</a>.</li>
<li><a href="https://github.com/sporkrb/spork">spork</a> - The server to speed up tests, how?, see provided link.</li>
<li><a href="https://github.com/guard/guard-spork">guard-spork</a> - Refreshes the spork server on changes, so that we don't need to.</li>
</ul>


<h2>Testing configuration</h2>

<h3>RSpec</h3>

<p><em>RSpec</em> will be used as the test framework for the <code>Just ToDo it</code> app.</p>

<p>Run generator to install <em>RSpec</em> to <em>Rails</em>:</p>

<p><code>bash
$ rails g rspec:install
create  .rspec
create  spec
create  spec/spec_helper.rb
</code></p>

<h3>Guard</h3>

<p><code>bash
$ bundle exec guard init
rspec guard added to Guardfile, feel free to edit it
spork guard added to Guardfile, feel free to edit it
</code></p>

<p>Configure <code>Guardfile</code> set the <em>Spork</em> on top and <em>RSpec</em> in bottom:</p>

<p>```ruby Guardfile
guard 'spork', :cucumber_env => { 'RAILS_ENV' => 'test' }, :rspec_env => { 'RAILS_ENV' => 'test' } do
  watch('config/application.rb')
  watch('config/environment.rb')
  watch(%r{<sup>config/environments/.+.rb$})</sup>
  watch(%r{<sup>config/initializers/.+.rb$})</sup>
  watch('spec/spec_helper.rb')
  watch(%r{<sup>spec/support/.+.rb$})</sup>
end</p>

<p>guard 'rspec', cli: "--drb" do
  ...
end
```</p>

<h3>Spork</h3>

<p>Bootstrap the <em>Spork</em>:</p>

<p><code>bash
$ spork --bootstrap
Using RSpec
Bootstrapping /Users/xajler/src/rb/just-todo-it/spec/spec_helper.rb.
Done. Edit /Users/xajler/src/rb/just-todo-it/spec/spec_helper.rb now with your favorite text editor and follow the instructions.
</code></p>

<h3>RSpec Helper</h3>

<p>Edit RSpec helper:</p>

<p><code>bash
$ vim spec/spec_helper.rb
</code>
And edit to include this content:</p>

<p>```ruby spec_helper.rb
require 'rubygems'
require 'spork'
require 'database_cleaner'</p>

<p>Spork.prefork do
  ENV["RAILS_ENV"] ||= 'test'
  require File.expand_path("../../config/environment", <strong>FILE</strong>)
  require 'rspec/rails'
  require 'capybara/rspec'</p>

<p>  Dir[Rails.root.join("spec/support/<em>*/</em>.rb")].each {|f| require f}</p>

<p>  DatabaseCleaner.strategy = :truncation</p>

<p>  RSpec.configure do |config|</p>

<pre><code>config.mock_with :rspec
config.include FactoryGirl::Syntax::Methods
config.use_transactional_fixtures = true
config.infer_base_class_for_anonymous_controllers = false
config.order = "random"
</code></pre>

<p>   end
end</p>

<p>Spork.each_run do
  FactoryGirl.reload
  DatabaseCleaner.clean
end
```</p>

<p>It uses <em>Spork</em> server and the aim is to have most things in <code>prefork</code> block where is
stuff run on load of <em>Spork</em>.</p>

<p>In <code>each_run</code> block we want put only necessary things, because it runs each time,
we are now having only reloading of <em>Factory Girl</em> factories, but maybe we will add something
from <code>prefork</code> if we would have some troubles with testing data.</p>

<p><em>DatabaseCleaner</em> is used to start, on before and clean it, on after running.
The strategy used for <em>DatabaseCleaner</em> is transaction, meaning to rollback
changes after the transaction queries are finished.</p>

<h3>Run Guard</h3>

<p>The testing environment is now configured, the <em>Guard</em> can be run:</p>

<p>```bash
$ guard
uard could not detect any of the supported notification libraries.
Guard is now watching at '/Users/xajler/src/rb/just-todo-it'
Starting Spork for RSpec
Using RSpec
Preloading Rails environment
Loading Spork.prefork block...
Spork is ready and listening on 8989!
Spork server for RSpec successfully started
Guard::RSpec is running
Running all specs
Running tests with args ["--drb", "-f", "progress", "-r", "/Users/xajler/.rbenv/versions/1.9.3-p194/lib/ruby/gems/1.9.1/gems/guard-rspec-2.1.0/lib/guard/rspec/formatter.rb", "-f", "Guard::RSpec::Formatter", "--out", "/dev/null", "--failure-exit-code", "2", "spec"]...
No examples found.</p>

<p>Finished in 0.11748 seconds
0 examples, 0 failures</p>

<p>Randomized with seed 7715</p>

<p>Done.
```</p>

<p>or use <code>bundle exec guard</code> to remove displayed warning.</p>

<p>To exit or stop the <code>guard</code> command use <code>Ctrl+C</code>.</p>

<h2>Pry as Rails Console</h2>

<p>And for the end we will set <em>Pry</em> as our default <em>Interactive Ruby</em> console.</p>

<p>Open the <code>development.rb</code>:</p>

<p><code>bash
$ vim config/enironments/development.rb
</code>
At the end of source file add code:</p>

<p><code>ruby
silence_warnings do
  require 'pry'
  IRB = Pry
end
</code></p>

<p>Try it out with <code>.pwd</code> and close the <em>Pry</em> with <code>exit</code> command:</p>

<p><code>bash
$ rails c
Loading development environment (Rails 3.2.8)
1.9.3 (main):0 &gt; .pwd
/Users/xajler/src/rb/just-todo-it
1.9.3 (main):0 &gt; exit
</code></p>

<h2>Commit Source</h2>

<p>First remove the <code>README.rdoc</code> file and create markdown <code>README.md</code>:</p>

<p><code>bash
$ rm README.rdoc
$ vim README.md
</code></p>

<p>Add simple description:</p>

<p><code>text README.md
The simple ToDo Rails App!
</code></p>

<h3>Initialize</h3>

<p>Initialize the <em>git</em> repository:</p>

<p><code>bash
$ git init
Initialized empty Git repository in /Users/xajler/src/rb/just-todo-it/.git/
</code></p>

<h3>Status</h3>

<p>See the status:</p>

<p>```bash
$ git status</p>

<h1>On branch master</h1>

<p>#</p>

<h1>Initial commit</h1>

<p>#</p>

<h1>Untracked files:</h1>

<h1>.gitignore</h1>

<h1>.rspec</h1>

<h1>Gemfile</h1>

<h1>Gemfile.lock</h1>

<h1>Guardfile</h1>

<h1>README.md</h1>

<h1>Rakefile</h1>

<h1>app/</h1>

<h1>config.ru</h1>

<h1>config/</h1>

<h1>db/</h1>

<h1>doc/</h1>

<h1>lib/</h1>

<h1>log/</h1>

<h1>public/</h1>

<h1>script/</h1>

<h1>spec/</h1>

<h1>vendor/</h1>

<p>nothing added to commit but untracked files present
```</p>

<h3>Add</h3>

<p>Then add all files:</p>

<p>```bash
$ git add .</p>

<h1>On branch master</h1>

<p>#</p>

<h1>Initial commit</h1>

<p>#</p>

<h1>Changes to be committed:</h1>

<h1>new file:   .gitignore</h1>

<h1>new file:   .rspec</h1>

<h1>new file:   Gemfile</h1>

<p>...
```</p>

<h3>Commit</h3>

<p>Commit the files to local repository:</p>

<p><code>
$ git commit -m 'Initial Commit. Created initial Rails app, added all needed Gems, testing configured'
[master (root-commit) e4517a6] Initial Commit. Created initial Rails app, added all needed Gems, testing configured
 38 files changed, 1086 insertions(+)
 create mode 100644 .gitignore
 create mode 100644 .rspec
 create mode 100644 Gemfile
</code></p>

<h3>Set Github Remote</h3>

<p>The app will be on <em>Github</em>. So after the new repository is created on <em>Github</em>, we can add
remote to the local repository:</p>

<p><code>bash
$ git remote add origin git@github.com:xajler/just-todo-it.git
</code></p>

<h3>Push to the Github</h3>

<p>After we add remote, it is now safe to push changes to <em>Github</em> remote repository:</p>

<p><code>
$ git push -u origin master
Counting objects: 63, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (47/47), done.
Writing objects: 100% (63/63), 23.32 KiB, done.
Total 63 (delta 2), reused 0 (delta 0)
To git@github.com:xajler/just-todo-it.git
 * [new branch]      master -&gt; master
Branch master set up to track remote branch master from origin.
</code></p>

<h2>Conclusion</h2>

<p>It this first part we have created a <code>JustToDoIt</code> Rails application.</p>

<p>And because we shall use <em>TDD</em> (Test Driven Development) to drive this app, we first
configure the testing environment including:</p>

<ul>
<li>RSpec</li>
<li>Factory Girl</li>
<li>Database Cleaner</li>
<li>Guard</li>
<li>Spork</li>
</ul>


<p>And for the end we setup the <em>Pry</em> to be a default for <em>Rails</em> console and commit the
source to the <em>Github</em> repository <a href="https://github.com/xajler/just-todo-it">xajler/just-todo-it</a>.</p>

<p>In second post we shall go with the creating the app logic in <em>TDD</em> way!</p>

<h2>Code</h2>

<p>The code is hosted on GitHub and can be cloned from the <a href="https://github.com/xajler/just-todo-it">xajler/just-todo-it</a>.</p>

<blockquote><p>Github xajler/just-todo-it commit for this post:</p>

<p><a href="https://github.com/xajler/just-todo-it/commit/e4517a6390f912850c63cc60085cbd57770d22ed">Initial Commit. Created initial Rails app, added all needed Gems, testing configured</a></p></blockquote>
]]></content>
  </entry>
  
</feed>
